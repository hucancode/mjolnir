#version 450

// Occlusion culling compute shader
// Tests objects against depth pyramid to determine visibility

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Camera {
    mat4 view;
    mat4 projection;
    vec4 viewport_params;
    vec4 position;
    vec4 frustum_planes[6];
};

// Push constants with camera/culling parameters
layout(push_constant) uniform PushConstants {
    uint cameraIndex;
    uint nodeCount;
    uint occlusionEnabled;
    uint _padding;
    float znear;
    float zfar;
    float pyramidWidth;
    float pyramidHeight;
} params;

// Input: node data (AABB/bounds)
layout(binding = 0) readonly buffer NodeData {
    vec4 nodeBounds[]; // xyz=center, w=radius (bounding sphere)
};

// Input: visibility from previous frame (reserved for future use)
layout(binding = 1) readonly buffer VisibilityPrev {
    uint visibilityPrev[];
};

// Output: visibility for current frame
layout(binding = 2) buffer VisibilityCurr {
    uint visibilityCurr[];
};

// Input: depth pyramid for occlusion testing
layout(binding = 3) uniform sampler2D depthPyramid;

// Camera data buffer
layout(binding = 4) readonly buffer CameraBuffer {
    Camera cameras[];
};

void main() {
    uint nodeIndex = gl_GlobalInvocationID.x;

    if (nodeIndex >= params.nodeCount) {
        return;
    }

    // Get node bounding sphere
    vec4 boundingSphere = nodeBounds[nodeIndex];
    vec3 worldCenter = boundingSphere.xyz;
    float radius = boundingSphere.w;

    uint prevFrameVisibility = visibilityPrev[nodeIndex];
    uint earlyVisibility = visibilityCurr[nodeIndex];

    if (radius <= 0.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    Camera camera = cameras[params.cameraIndex];

    bool visible = true;
    bool forcedVisible = (prevFrameVisibility != 0u) || (earlyVisibility != 0u);

    // Frustum culling using world-space planes
    for (int i = 0; i < 6 && visible; ++i) {
        vec4 plane = camera.frustum_planes[i];
        float distance = dot(plane.xyz, worldCenter) + plane.w;
        if (distance < -radius) {
            visible = false;
        }
    }

    if (!visible) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    if (forcedVisible || params.occlusionEnabled == 0u) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec4 viewCenter4 = camera.view * vec4(worldCenter, 1.0);
    vec3 viewCenter = viewCenter4.xyz;

    float centerDistance = length(viewCenter);
    if (centerDistance <= radius + 1e-5) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec3 viewDir = viewCenter / centerDistance;
    vec3 right = cross(vec3(0.0, 1.0, 0.0), viewDir);
    float rightLength = length(right);
    if (rightLength < 1e-4) {
        right = cross(vec3(1.0, 0.0, 0.0), viewDir);
        rightLength = length(right);
    }
    if (rightLength < 1e-4) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }
    right /= rightLength;
    vec3 up = cross(viewDir, right);

    vec2 ndcMin = vec2( 1.0);
    vec2 ndcMax = vec2(-1.0);
    bool validProjection = true;

    vec3 offsets[4] = vec3[](
        right * radius,
        -right * radius,
        up * radius,
        -up * radius
    );

    for (int i = 0; i < 4; ++i) {
        vec4 clip = camera.projection * vec4(viewCenter + offsets[i], 1.0);
        if (clip.w <= 0.0) {
            validProjection = false;
            break;
        }
        vec2 ndc = clip.xy / clip.w;
        ndcMin = min(ndcMin, ndc);
        ndcMax = max(ndcMax, ndc);
    }

    if (!validProjection) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    if (ndcMin.x > 1.0 || ndcMax.x < -1.0 || ndcMin.y > 1.0 || ndcMax.y < -1.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    ndcMin = clamp(ndcMin, vec2(-1.0), vec2(1.0));
    ndcMax = clamp(ndcMax, vec2(-1.0), vec2(1.0));

    vec2 pyramidDim = vec2(params.pyramidWidth, params.pyramidHeight);
    if (pyramidDim.x <= 0.0 || pyramidDim.y <= 0.0) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec2 uvMin = ndcMin * 0.5 + 0.5;
    vec2 uvMax = ndcMax * 0.5 + 0.5;
    vec2 uvSize = max(uvMax - uvMin, vec2(0.0));

    float pixelWidth = uvSize.x * pyramidDim.x;
    float pixelHeight = uvSize.y * pyramidDim.y;
    float maxDimension = max(max(pixelWidth, pixelHeight), 1.0);
    float pyramidMaxDim = max(pyramidDim.x, pyramidDim.y);
    float maxAvailableLevel = 0.0;
    if (pyramidMaxDim > 0.0) {
        maxAvailableLevel = log2(pyramidMaxDim);
    }
    float mipLevel = clamp(log2(maxDimension), 0.0, maxAvailableLevel);

    vec3 nearPointView = viewCenter - viewDir * radius;

    if (nearPointView.z >= -params.znear) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    float objectDepth = 1.0;
    bool depthValid = false;

    vec3 depthOffsets[6] = vec3[](
        vec3(0.0),
        right * radius,
        -right * radius,
        up * radius,
        -up * radius,
        -viewDir * radius
    );

    for (int i = 0; i < 6; ++i) {
        vec4 clip = camera.projection * vec4(viewCenter + depthOffsets[i], 1.0);
        if (clip.w <= 0.0) {
            continue;
        }
        float depth = clip.z / clip.w;
        depth = depth * 0.5 + 0.5;
        depth = clamp(depth, 0.0, 1.0);
        objectDepth = min(objectDepth, depth);
        depthValid = true;
    }

    if (!depthValid) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    const float depthBias = 1e-2;

    int startLevel = int(floor(mipLevel + 0.5));
    if (startLevel < 0) {
        startLevel = 0;
    }

    bool visibleResult = true;

    for (int level = startLevel; level >= 0; --level) {
        float levelFloat = float(level);
        float levelScale = exp2(levelFloat);
        vec2 texelSize = levelScale / pyramidDim;
        vec2 expandedMin = clamp(uvMin - texelSize, vec2(0.0), vec2(1.0));
        vec2 expandedMax = clamp(uvMax + texelSize, vec2(0.0), vec2(1.0));

        vec2 uvCenter = (expandedMin + expandedMax) * 0.5;
        vec2 uvLowerRight = vec2(expandedMax.x, expandedMin.y);
        vec2 uvUpperLeft = vec2(expandedMin.x, expandedMax.y);

        float minDepth = 1.0;
        vec2 samples[9] = vec2[](
            uvCenter,
            expandedMin,
            expandedMax,
            uvUpperLeft,
            uvLowerRight,
            vec2(expandedMin.x, uvCenter.y),
            vec2(expandedMax.x, uvCenter.y),
            vec2(uvCenter.x, expandedMin.y),
            vec2(uvCenter.x, expandedMax.y)
        );

        for (int i = 0; i < 9; ++i) {
            minDepth = min(minDepth, textureLod(depthPyramid, samples[i], levelFloat).x);
        }

        if (minDepth <= 1e-5) {
            visibleResult = true;
            break;
        }

        if (objectDepth <= minDepth + depthBias) {
            visibleResult = true;
            break;
        }

        visibleResult = false;
    }

    visibilityCurr[nodeIndex] = visibleResult ? 1u : 0u;
}
