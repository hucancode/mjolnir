#version 450

// Occlusion culling compute shader
// Tests objects against depth pyramid to determine visibility

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Camera {
    mat4 view;
    mat4 projection;
    vec4 viewport_params;
    vec4 position;
    vec4 frustum_planes[6];
};

// Push constants with camera/culling parameters
layout(push_constant) uniform PushConstants {
    uint cameraIndex;
    uint nodeCount;
    uint occlusionEnabled;
    uint _padding;
    float znear;
    float zfar;
    float pyramidWidth;
    float pyramidHeight;
} params;

// Input: node data (AABB/bounds)
layout(binding = 0) readonly buffer NodeData {
    vec4 nodeBounds[]; // xyz=center, w=radius (bounding sphere)
};

// Input: visibility from previous frame (reserved for future use)
layout(binding = 1) readonly buffer VisibilityPrev {
    uint visibilityPrev[];
};

// Output: visibility for current frame
layout(binding = 2) buffer VisibilityCurr {
    uint visibilityCurr[];
};

// Input: depth pyramid for occlusion testing
layout(binding = 3) uniform sampler2D depthPyramid;

// Camera data buffer
layout(binding = 4) readonly buffer CameraBuffer {
    Camera cameras[];
};

void main() {
    uint nodeIndex = gl_GlobalInvocationID.x;

    if (nodeIndex >= params.nodeCount) {
        return;
    }

    // Get node bounding sphere
    vec4 boundingSphere = nodeBounds[nodeIndex];
    vec3 worldCenter = boundingSphere.xyz;
    float radius = boundingSphere.w;

    uint prevFrameVisibility = visibilityPrev[nodeIndex];
    uint earlyVisibility = visibilityCurr[nodeIndex];

    if (radius <= 0.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    Camera camera = cameras[params.cameraIndex];

    bool visible = true;
    bool forcedVisible = (prevFrameVisibility != 0u) || (earlyVisibility != 0u);

    // Frustum culling using world-space planes
    for (int i = 0; i < 6 && visible; ++i) {
        vec4 plane = camera.frustum_planes[i];
        float distance = dot(plane.xyz, worldCenter) + plane.w;
        if (distance < -radius) {
            visible = false;
        }
    }

    if (!visible) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    if (forcedVisible || params.occlusionEnabled == 0u) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec4 viewCenter4 = camera.view * vec4(worldCenter, 1.0);
    vec3 viewCenter = viewCenter4.xyz;

    float centerDistance = length(viewCenter);
    if (centerDistance <= radius + 1e-5) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec3 viewDir = viewCenter / centerDistance;
    vec3 right = cross(vec3(0.0, 1.0, 0.0), viewDir);
    float rightLength = length(right);
    if (rightLength < 1e-4) {
        right = cross(vec3(1.0, 0.0, 0.0), viewDir);
        rightLength = length(right);
    }
    if (rightLength < 1e-4) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }
    right /= rightLength;
    vec3 up = cross(viewDir, right);

    vec2 ndcMin = vec2( 1.0);
    vec2 ndcMax = vec2(-1.0);
    bool validProjection = true;

    vec3 offsets[4] = vec3[](
        right * radius,
        -right * radius,
        up * radius,
        -up * radius
    );

    for (int i = 0; i < 4; ++i) {
        vec4 clip = camera.projection * vec4(viewCenter + offsets[i], 1.0);
        if (clip.w <= 0.0) {
            validProjection = false;
            break;
        }
        vec2 ndc = clip.xy / clip.w;
        ndcMin = min(ndcMin, ndc);
        ndcMax = max(ndcMax, ndc);
    }

    if (!validProjection) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    if (ndcMin.x > 1.0 || ndcMax.x < -1.0 || ndcMin.y > 1.0 || ndcMax.y < -1.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    ndcMin = clamp(ndcMin, vec2(-1.0), vec2(1.0));
    ndcMax = clamp(ndcMax, vec2(-1.0), vec2(1.0));

    vec2 uvMin = ndcMin * 0.5 + 0.5;
    vec2 uvMax = ndcMax * 0.5 + 0.5;
    vec2 uvSize = max(uvMax - uvMin, vec2(0.0));

    float pixelWidth = uvSize.x * params.pyramidWidth;
    float pixelHeight = uvSize.y * params.pyramidHeight;
    float maxDimension = max(max(pixelWidth, pixelHeight), 1.0);
    float pyramidMaxDim = max(params.pyramidWidth, params.pyramidHeight);
    float maxAvailableLevel = 0.0;
    if (pyramidMaxDim > 0.0) {
        maxAvailableLevel = log2(pyramidMaxDim);
    }
    float mipLevel = clamp(log2(maxDimension), 0.0, maxAvailableLevel);

    vec2 uvCenter = (uvMin + uvMax) * 0.5;
    float maxDepth = textureLod(depthPyramid, uvCenter, mipLevel).x;

    vec3 nearPointView = viewCenter - viewDir * radius;
    vec4 clipNear = camera.projection * vec4(nearPointView, 1.0);
    if (clipNear.w <= 0.0) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    float objectDepth = clipNear.z / clipNear.w;
    objectDepth = clamp(objectDepth, 0.0, 1.0);

    if (nearPointView.z >= -params.znear) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    if (maxDepth <= 1e-5) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    const float depthBias = 1e-2;
    visible = objectDepth <= maxDepth + depthBias;

    visibilityCurr[nodeIndex] = visible ? 1u : 0u;
}
