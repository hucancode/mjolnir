#version 450

// Occlusion culling compute shader
// Tests objects against depth pyramid to determine visibility

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Camera {
    mat4 view;
    mat4 projection;
    vec4 viewport_params;
    vec4 position;
    vec4 frustum_planes[6];
};

// Push constants with camera/culling parameters
layout(push_constant) uniform PushConstants {
    uint cameraIndex;
    uint nodeCount;
    uint occlusionEnabled;
    uint _padding;
    float znear;
    float zfar;
    float pyramidWidth;
    float pyramidHeight;
} params;

// Input: node data (AABB/bounds)
layout(binding = 0) readonly buffer NodeData {
    vec4 nodeBounds[]; // xyz=center, w=radius (bounding sphere)
};

// Input: visibility from previous frame (reserved for future use)
layout(binding = 1) readonly buffer VisibilityPrev {
    uint visibilityPrev[];
};

// Output: visibility for current frame
layout(binding = 2) writeonly buffer VisibilityCurr {
    uint visibilityCurr[];
};

// Input: depth pyramid for occlusion testing
layout(binding = 3) uniform sampler2D depthPyramid;

// Camera data buffer
layout(binding = 4) readonly buffer CameraBuffer {
    Camera cameras[];
};

void main() {
    uint nodeIndex = gl_GlobalInvocationID.x;

    if (nodeIndex >= params.nodeCount) {
        return;
    }

    // Get node bounding sphere
    vec4 boundingSphere = nodeBounds[nodeIndex];
    vec3 worldCenter = boundingSphere.xyz;
    float radius = boundingSphere.w;

    if (radius <= 0.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    Camera camera = cameras[params.cameraIndex];

    bool visible = true;

    // Frustum culling using world-space planes
    for (int i = 0; i < 6 && visible; ++i) {
        vec4 plane = camera.frustum_planes[i];
        float distance = dot(plane.xyz, worldCenter) + plane.w;
        if (distance < -radius) {
            visible = false;
        }
    }

    if (!visible) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    if (params.occlusionEnabled == 0u) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec4 viewCenter4 = camera.view * vec4(worldCenter, 1.0);
    vec3 viewCenter = viewCenter4.xyz;

    // If the sphere intersects or is behind the near plane, keep it visible
    if (-viewCenter.z + radius <= params.znear) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    vec2 ndcMin = vec2( 1.0);
    vec2 ndcMax = vec2(-1.0);
    bool validProjection = true;

    vec3 offsets[4] = vec3[](
        vec3( radius, 0.0, 0.0),
        vec3(-radius, 0.0, 0.0),
        vec3(0.0,  radius, 0.0),
        vec3(0.0, -radius, 0.0)
    );

    for (int i = 0; i < 4; ++i) {
        vec4 clip = camera.projection * vec4(viewCenter + offsets[i], 1.0);
        if (clip.w <= 0.0) {
            validProjection = false;
            break;
        }
        vec2 ndc = clip.xy / clip.w;
        ndcMin = min(ndcMin, ndc);
        ndcMax = max(ndcMax, ndc);
    }

    if (!validProjection) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    if (ndcMin.x > 1.0 || ndcMax.x < -1.0 || ndcMin.y > 1.0 || ndcMax.y < -1.0) {
        visibilityCurr[nodeIndex] = 0u;
        return;
    }

    ndcMin = clamp(ndcMin, vec2(-1.0), vec2(1.0));
    ndcMax = clamp(ndcMax, vec2(-1.0), vec2(1.0));

    vec2 uvMin = ndcMin * 0.5 + 0.5;
    vec2 uvMax = ndcMax * 0.5 + 0.5;
    vec2 uvSize = max(uvMax - uvMin, vec2(0.0));

    float pixelWidth = uvSize.x * params.pyramidWidth;
    float pixelHeight = uvSize.y * params.pyramidHeight;
    float maxDimension = max(max(pixelWidth, pixelHeight), 1.0);
    float mipLevel = max(0.0, log2(maxDimension));

    vec2 uvCenter = (uvMin + uvMax) * 0.5;
    float minDepth = textureLod(depthPyramid, uvCenter, mipLevel).x;

    vec3 nearPointView = viewCenter;
    nearPointView.z += radius;
    vec4 clipNear = camera.projection * vec4(nearPointView, 1.0);
    if (clipNear.w <= 0.0) {
        visibilityCurr[nodeIndex] = 1u;
        return;
    }

    float objectDepth = clipNear.z / clipNear.w;

    const float depthBias = 1e-3;
    visible = objectDepth <= minDepth + depthBias;

    visibilityCurr[nodeIndex] = visible ? 1u : 0u;
}
