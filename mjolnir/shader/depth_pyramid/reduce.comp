#version 450

// Hierarchical depth buffer reduction for occlusion culling
// Based on Niagara renderer's depth pyramid approach
// Each level reduces by 2x2, storing minimum depth (furthest from camera)

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, r32f) uniform writeonly image2D outDepth;
layout(binding = 1) uniform sampler2D inDepth;

layout(push_constant) uniform PushConstants {
    vec2 imageSize;  // Output mip size
    uint mipLevel;
    uint _padding;
} params;

void main() {
    uvec2 pos = gl_GlobalInvocationID.xy;
    
    // Check bounds
    if (pos.x >= uint(params.imageSize.x) || pos.y >= uint(params.imageSize.y)) {
        return;
    }
    
    // Sample 2x2 quad from source level and compute MIN
    // We use reverse Z (1.0 = near, 0.0 = far), so MIN gives us the furthest depth
    // This creates a conservative depth pyramid for occlusion testing
    vec2 texelSize = 1.0 / (params.imageSize * 2.0);
    vec2 uv = (vec2(pos) * 2.0 + vec2(0.5)) * texelSize;
    
    // Sample 2x2 quad
    float d0 = texture(inDepth, uv + vec2(0.0, 0.0) * texelSize).r;
    float d1 = texture(inDepth, uv + vec2(1.0, 0.0) * texelSize).r;
    float d2 = texture(inDepth, uv + vec2(0.0, 1.0) * texelSize).r;
    float d3 = texture(inDepth, uv + vec2(1.0, 1.0) * texelSize).r;
    
    // MIN reduction for conservative occlusion (furthest depth)
    float minDepth = min(min(d0, d1), min(d2, d3));
    
    imageStore(outDepth, ivec2(pos), vec4(minDepth));
}
