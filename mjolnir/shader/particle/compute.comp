#version 450

const int MAX_PARTICLES = 65536;
const int MAX_FORCE_FIELDS = 32;

struct Particle {
    vec4 position;
    vec4 velocity;
    vec4 color_start;
    vec4 color_end;
    vec4 color;
    float size;
    float size_end;
    float life;
    float max_life;
    uint is_dead;
    float weight;
    float padding[2];
};

struct ForceField {
    uint behavior; // 0: ATTRACT, 1: REPEL, 2: ORBIT
    float strength;
    float area_of_effect;
    float fade;
    mat4 transform;
};

layout(binding = 0) uniform ParamsBuffer {
    uint particle_count;
    float deltaTime;
    float padding[2];
};

layout(binding = 1) buffer ParticleBuffer {
    Particle particles[];
};

layout(binding = 3) buffer ForceFieldBuffer {
    ForceField forcefields[];
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Random number generation
float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 random_direction(vec3 base_dir, float spread, vec2 seed) {
    if (spread <= 0.0) return base_dir;

    float theta = rand(seed) * 2.0 * 3.14159265;
    float phi = acos(2.0 * rand(seed.yx) - 1.0);
    float r = spread * rand(seed * 2.0);

    vec3 random_offset = vec3(
        r * sin(phi) * cos(theta),
        r * sin(phi) * sin(theta),
        r * cos(phi)
    );

    return normalize(base_dir + random_offset);
}

const vec3 GRAVITY = vec3(0.0, -9.8, 0.0);

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= MAX_PARTICLES) return;

    // Skip dead particles - they don't need processing
    if (particles[i].is_dead != 0) return;

    if (particles[i].life > 0.0) {
        // Apply force fields
        vec3 p = particles[i].position.xyz;
        for (int f = 0; f < MAX_FORCE_FIELDS; ++f) {
            ForceField ff = forcefields[f];
            // Ignore unused slots (area_of_effect == 0 means unused)
            if (ff.area_of_effect <= 0.0) continue;
            vec3 ff_pos = (ff.transform * vec4(0,0,0,1)).xyz;
            vec3 to_particle = p - ff_pos;
            float dist = length(to_particle);
            if (dist > ff.area_of_effect) continue;
            float fade = ff.fade;
            float effect = 1.0 - clamp(dist / ff.area_of_effect, 0.0, 1.0);
            effect *= fade;
            vec3 dir = normalize(ff_pos - p);
            if (ff.behavior == 0) { // ATTRACT
                particles[i].velocity.xyz += dir * ff.strength * effect * deltaTime;
            } else if (ff.behavior == 1) { // REPEL
                particles[i].velocity.xyz -= dir * ff.strength * effect * deltaTime;
            } else if (ff.behavior == 2) { // ORBIT
                vec3 up = vec3(0,1,0);
                vec3 tangent = normalize(cross(up, dir));
                particles[i].velocity.xyz += tangent * ff.strength * effect * deltaTime;
            }
        }
        // Update particle physics
        particles[i].velocity.xyz += GRAVITY * particles[i].weight * deltaTime;
        particles[i].position += particles[i].velocity * deltaTime;
        particles[i].life -= deltaTime;

        // Update particle color based on life ratio
        float life_ratio = particles[i].life / particles[i].max_life;
        particles[i].color = mix(particles[i].color_end, particles[i].color_start, life_ratio);

        // Update particle size based on life ratio (interpolate from size to size_end)
        particles[i].size = mix(particles[i].size_end, particles[i].size, life_ratio);

        // Mark particle as dead if life is exhausted
        if (particles[i].life <= 0.0) {
            particles[i].is_dead = 1;
            particles[i].life = 0.0;
        }
    }
}
