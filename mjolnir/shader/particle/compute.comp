#version 450

struct Particle {
    vec3 position;
    float size;
    vec3 velocity;
    float life;
    vec4 color_start;
    vec4 color_end;
    vec4 color;
    float max_life;
};

struct Emitter {
    mat4 transform;
    float emission_rate;
    float particle_lifetime;
    vec3 initial_velocity;
    float velocity_spread;
    vec4 color_start;
    vec4 color_end;
    float size_start;
    float size_end;
    bool enabled;
    float time_accumulator;
};
// Bindings
layout(binding = 0) uniform ParamsBuffer {
    uint particle_count;
    uint emitter_count;
    float deltaTime;
    float padding;
};

layout(binding = 1) buffer ParticleBuffer {
    // matches Particle struct in Odin
    Particle particles[];
};

layout(binding = 2) buffer EmitterBuffer {
    // matches Emitter struct in Odin
    Emitter emitters[];
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Random number generation
float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 random_direction(vec3 base_dir, float spread, vec2 seed) {
    if (spread <= 0.0) return base_dir;

    float theta = rand(seed) * 2.0 * 3.14159265;
    float phi = acos(2.0 * rand(seed.yx) - 1.0);
    float r = spread * rand(seed * 2.0);

    vec3 random_offset = vec3(
        r * sin(phi) * cos(theta),
        r * sin(phi) * sin(theta),
        r * cos(phi)
    );

    return normalize(base_dir + random_offset);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= particles.length()) return;

    Particle particle = particles[index];

    // Update existing particles
    if (particle.life > 0.0) {
        // Update position
        particle.position += particle.velocity * deltaTime;

        // Update lifetime
        particle.life -= deltaTime;

        // Interpolate color based on lifetime progress
        float life_progress = particle.life / particle.max_life;
        particle.color = mix(particle.color_end, particle.color_start, life_progress);

        // Store updated particle
        particles[index] = particle;
        return;
    }

    // Try to spawn new particles from emitters
    for (int i = 0; i < emitter_count; i++) {
        Emitter emitter = emitters[i];
        if (!emitter.enabled) continue;

        // Check if this particle slot should spawn from this emitter
        if (emitter.time_accumulator >= (1.0 / emitter.emission_rate)) {
            // Reset accumulator (approximately)
            emitter.time_accumulator -= (1.0 / emitter.emission_rate);

            // Initialize new particle
            vec2 random_seed = vec2(float(index), float(i));
            vec3 spawn_position = vec3(emitter.transform[3]); // Translation component
            vec3 direction = random_direction(
                emitter.initial_velocity,
                emitter.velocity_spread,
                random_seed
            );

            particle.position = spawn_position;
            particle.velocity = direction * length(emitter.initial_velocity);
            particle.life = emitter.particle_lifetime;
            particle.max_life = emitter.particle_lifetime;
            particle.color_start = emitter.color_start;
            particle.color_end = emitter.color_end;
            particle.size = emitter.size_start;

            // Store spawned particle
            particles[index] = particle;
            break;
        }
    }
}
