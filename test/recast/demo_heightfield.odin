#+feature dynamic-literals
package test_recast

import "core:log"
import "core:math"
import "core:os"
import "core:fmt"
import "core:time"
import "core:testing"
import "../../mjolnir/navigation/recast"

@(test)
test_demo_heightfield :: proc(t: ^testing.T) {
    testing.set_fail_timeout(t, 30 * time.Second)
    
    vertices := [dynamic]f32{
        -10, 0, -10,
         10, 0, -10,
         10, 0,  10,
        -10, 0,  10,
        
        -2, 0, -2,
         2, 0, -2,
         2, 0,  2,
        -2, 0,  2,
        -2, 3,  2,
        -2, 3, -2,
         2, 3, -2,
         2, 3,  2,
    }
    defer delete(vertices)
    
    indices := [dynamic]i32{
        0, 1, 2,
        0, 2, 3,
        
        4, 5, 6,
        4, 6, 7,
        4, 7, 8,
        4, 8, 9,
        5, 10, 11,
        5, 11, 6,
        9, 10, 5,
        9, 5, 4,
        8, 11, 10,
        8, 10, 9,
        7, 6, 11,
        7, 11, 8,
    }
    defer delete(indices)
    
    areas := make([]u8, len(indices) / 3)
    defer delete(areas)
    
    for i in 0..<len(areas) {
        areas[i] = recast.RC_WALKABLE_AREA
    }
    
    config := recast.Config{
        cs = 0.3,
        ch = 0.2,
        walkable_slope_angle = 45,
        walkable_height = 10,
        walkable_climb = 4,
        walkable_radius = 1,
        max_edge_len = 12,
        max_simplification_error = 1.3,
        min_region_area = 8,
        merge_region_area = 20,
        max_verts_per_poly = 6,
        detail_sample_dist = 6,
        detail_sample_max_error = 1,
    }
    
    pmesh, dmesh, ok := recast.build_navmesh(vertices[:], indices[:], areas[:], config)
    
    if !ok {
        log.error("Failed to build navigation mesh")
        testing.fail(t)
        return
    }
    
    defer recast.free_poly_mesh(pmesh)
    defer recast.free_poly_mesh_detail(dmesh)
    
    log.info("Successfully built navigation mesh")
    if pmesh != nil {
        log.infof("Polymesh: %d vertices, %d polygons", len(pmesh.verts), pmesh.npolys)
    }
    
    // Note: In the minimal API, we don't have access to intermediate heightfield data
    log.info("Note: Heightfield visualization not available in minimal API")
}

export_heightfield_as_obj :: proc(hf: ^recast.Heightfield, filename: string) {
    file, err := os.open(filename, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
    if err != 0 {
        log.errorf("Failed to create file: %s", filename)
        return
    }
    defer os.close(file)
    
    os.write_string(file, "# Heightfield visualization\n")
    os.write_string(file, "# Generated by Recast\n\n")
    
    cell_size := hf.cs
    cell_height := hf.ch
    origin := hf.bmin
    
    vertex_count := 0
    for y in 0..<hf.height {
        for x in 0..<hf.width {
            cell := hf.spans[x + y * hf.width]
            span := cell
            
            for span != nil {
                bot := origin.y + f32(span.data.smin) * cell_height
                top := origin.y + f32(span.data.smax) * cell_height
                
                wx := origin.x + f32(x) * cell_size
                wz := origin.z + f32(y) * cell_size
                
                fmt.fprintf(file, "v %f %f %f\n", wx, bot, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, bot, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, bot, wz + cell_size)
                fmt.fprintf(file, "v %f %f %f\n", wx, bot, wz + cell_size)
                
                fmt.fprintf(file, "v %f %f %f\n", wx, top, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, top, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, top, wz + cell_size)
                fmt.fprintf(file, "v %f %f %f\n", wx, top, wz + cell_size)
                
                base := vertex_count * 8 + 1
                fmt.fprintf(file, "f %d %d %d %d\n", base, base+1, base+2, base+3)
                fmt.fprintf(file, "f %d %d %d %d\n", base+7, base+6, base+5, base+4)
                fmt.fprintf(file, "f %d %d %d %d\n", base, base+3, base+7, base+4)
                fmt.fprintf(file, "f %d %d %d %d\n", base+2, base+1, base+5, base+6)
                fmt.fprintf(file, "f %d %d %d %d\n", base+3, base+2, base+6, base+7)
                fmt.fprintf(file, "f %d %d %d %d\n", base+1, base, base+4, base+5)
                
                vertex_count += 1
                span = span.next
            }
        }
    }
    
    log.infof("Exported %d voxels", vertex_count)
}

export_compact_heightfield_as_obj :: proc(chf: ^recast.Compact_Heightfield, filename: string) {
    file, err := os.open(filename, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
    if err != 0 {
        log.errorf("Failed to create file: %s", filename)
        return
    }
    defer os.close(file)
    
    os.write_string(file, "# Compact Heightfield visualization\n")
    os.write_string(file, "# Generated by Recast\n\n")
    
    cell_size := chf.cs
    cell_height := chf.ch
    origin := chf.bmin
    
    vertex_count := 0
    for y in 0..<chf.height {
        for x in 0..<chf.width {
            cell := &chf.cells[x + y * chf.width]
            
            for i in cell.index..<cell.index + u32(cell.count) {
                span := &chf.spans[i]
                
                bot := origin.y + f32(span.y) * cell_height
                top := bot + f32(span.h) * cell_height
                
                wx := origin.x + f32(x) * cell_size
                wz := origin.z + f32(y) * cell_size
                
                fmt.fprintf(file, "v %f %f %f\n", wx, bot, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, bot, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, bot, wz + cell_size)
                fmt.fprintf(file, "v %f %f %f\n", wx, bot, wz + cell_size)
                
                fmt.fprintf(file, "v %f %f %f\n", wx, top, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, top, wz)
                fmt.fprintf(file, "v %f %f %f\n", wx + cell_size, top, wz + cell_size)
                fmt.fprintf(file, "v %f %f %f\n", wx, top, wz + cell_size)
                
                base := vertex_count * 8 + 1
                
                color_comment := ""
                if chf.areas[i] == 0 {
                    color_comment = " # Unwalkable"
                } else {
                    color_comment = " # Walkable"
                }
                
                fmt.fprintf(file, "f %d %d %d %d%s\n", base, base+1, base+2, base+3, color_comment)
                os.write_string(file, fmt.aprintf("f %d %d %d %d\n", base+7, base+6, base+5, base+4))
                os.write_string(file, fmt.aprintf("f %d %d %d %d\n", base, base+3, base+7, base+4))
                os.write_string(file, fmt.aprintf("f %d %d %d %d\n", base+2, base+1, base+5, base+6))
                os.write_string(file, fmt.aprintf("f %d %d %d %d\n", base+3, base+2, base+6, base+7))
                os.write_string(file, fmt.aprintf("f %d %d %d %d\n", base+1, base, base+4, base+5))
                
                vertex_count += 1
            }
        }
    }
    
    log.infof("Exported %d compact voxels", vertex_count)
}